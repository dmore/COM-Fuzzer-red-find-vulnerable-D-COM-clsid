#  Copyright 2025 Remco van der Meer. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


<#
.SYNOPSIS
Decides relationship type for Fuzzed inputs in Neo4j
.DESCRIPTION
This function decides relationship type for Fuzzed inputs in Neo4j
#>
function Add-FuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )
    if ($JsonFilePath -match "Allowed") {
        Add-AllowsFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Denied") {
        Add-AccessDeniedFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Error") {
        Add-ErrorFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Parameters") {
        Add-ParameterInputNodeFromJson($JsonFilePath)        
    } else {
        Write-Host "Error importing data to Neo4j, check your path $_"
    }
}

<#
.SYNOPSIS
Gets the necessary parameters from the allowed fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the allowed fuzz input JSON file
.PARAMETER JsonFilePath
Specify the allowed json file that was generated by Invoke-ComFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-AllowsFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath -Raw | ConvertFrom-Json

    foreach ($clsid in $jsonData.PSObject.Properties.Name) {
        $interfaces = $jsonData.$clsid

        foreach ($interfaceId in $interfaces.PSObject.Properties.Name) {
            $methods = $interfaces.$interfaceId

            foreach ($method in $methods) {
                Add-AllowsFuzzedInputNode -MethodName $method.ProcedureName `
                                          -ComClass $clsid `
                                          -ComInterface $interfaceId `
                                          -ProcedureName $method.ProcedureName `
                                          -MethodDefinition $method.ProcedureDefinition `
                                          -Service $method.Service `
                                          -FuzzInput $method.FuzzInput `
                                          -Output $method.Output `
                                          -WindowsMessage $method.WindowsMessage
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for Allowed Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for Allowed Fuzzed inputs in Neo4j
#>
function Add-AllowsFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$ComClass,
        [string]$ComInterface,
        [string]$ProcedureName, 
        [string]$MethodDefinition,
        [string]$Service,
        [string]$FuzzInput, 
        [string]$Output,
        [string]$windowsMessage
    )
    $cypher = @"
        MERGE (comClass:ComClass { Name: `"$ComClass`" })
        MERGE (comInterface:ComInterface { UUID: `"$ComInterface`" })
        MERGE (comClass)-[:HAS_INTERFACE]->(comInterface)
        MERGE (method:Method { Name: `"$ProcedureName`", Definition: `"$MethodDefinition`" })
        MERGE (comInterface)-[:WITH_METHOD]->(method)
        CREATE (allowsinput:AllowsInput { 
            Name: `"$MethodName`", 
            Definition: `"$MethodDefinition`", 
            FuzzInput: `"$FuzzInput`", 
            FuzzOutput: `"$Output`",
            WindowsMessage: `"$windowsMessage`"
        })
        MERGE (method)-[:ALLOWS_INPUT]->(allowsinput)

        FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
            MERGE (service:Service { Name: `"$Service`" })
            MERGE (ComServer)-[:SERVICE]->(service)
        )        
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

<#
.SYNOPSIS
Gets the necessary parameters from the access denied fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the access denied fuzz input JSON file
.PARAMETER JsonFilePath
Specify the access denied json file that was generated by Invoke-ComFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-AccessDeniedFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath -Raw | ConvertFrom-Json

    foreach ($clsid in $jsonData.PSObject.Properties.Name) {
        $interfaces = $jsonData.$clsid

        foreach ($interfaceId in $interfaces.PSObject.Properties.Name) {
            $methods = $interfaces.$interfaceId

            foreach ($method in $methods) {
                Add-AccessDeniedFuzzedInputNode -MethodName $method.ProcedureName `
                                          -ComClass $clsid `
                                          -ComInterface $interfaceId `
                                          -ProcedureName $method.ProcedureName `
                                          -MethodDefinition $method.ProcedureDefinition `
                                          -Service $method.Service `
                                          -FuzzInput $method.FuzzInput `
                                          -Output $method.Output `
                                          -WindowsMessage $method.WindowsMessage
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for Access Denied Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for Access Denied Fuzzed inputs in Neo4j
#>
function Add-AccessDeniedFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$ComClass,
        [string]$ComInterface,
        [string]$ProcedureName, 
        [string]$MethodDefinition,
        [string]$Service,
        [string]$FuzzInput, 
        [string]$Output,
        [string]$windowsMessage
    )
    $cypher = @"
        MERGE (comClass:ComClass { Name: `"$ComClass`" })
        MERGE (comInterface:ComInterface { UUID: `"$ComInterface`" })
        MERGE (comClass)-[:HAS_INTERFACE]->(comInterface)
        MERGE (method:Method { Name: `"$ProcedureName`", Definition: `"$MethodDefinition`" })
        MERGE (comInterface)-[:WITH_METHOD]->(method)
        MERGE (accessdenied:AccessDenied { 
            Name: `"$MethodName`", 
            Definition: `"$MethodDefinition`", 
            FuzzInput: `"$FuzzInput`", 
            FuzzOutput: `"$Output`",
            WindowsMessage: `"$windowsMessage`"
        })
        MERGE (method)-[:ACCESS_DENIED]->(accessdenied)

        FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
            MERGE (service:Service { Name: `"$Service`" })
            MERGE (ComServer)-[:SERVICE]->(service)
        )        
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

<#
.SYNOPSIS
Gets the necessary parameters from the error fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the error fuzz input JSON file
.PARAMETER JsonFilePath
Specify the error json file that was generated by Invoke-ComFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-ErrorFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json

    # Loop through each key in the JSON (each DLL in your case)
    foreach ($dllName in $jsonData.PSObject.Properties.Name) {
        # Loop through each method ID (UUID or unique key in your JSON)
        foreach ($methodId in $jsonData.$dllName.PSObject.Properties.Name) {
            # Loop through the array of method data for each method ID
            foreach ($method in $jsonData.$dllName.$methodId) {
                # Call the original Add-ErrorFuzzedInputNode function with the appropriate parameters
                Add-ErrorFuzzedInputNode -MethodName $method.MethodName `
                                         -ComServerName $dllName `
                                         -ComInterface $methodId `
                                         -Endpoint $method.Endpoint `
                                         -ProcedureName $method.ProcedureName `
                                         -MethodDefinition $method.MethodDefinition `
                                         -Service $method.Service `
                                         -FuzzInput $method.FuzzInput `
                                         -Errormessage $method.ErrorMessage
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for error Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for error Fuzzed inputs in Neo4j
#>
function Add-ErrorFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$ComServerName, 
        [string]$ComInterface,
        [string]$Endpoint, 
        [string]$ProcedureName, 
        [string]$MethodDefinition, 
        [string]$FuzzInput,
        [string]$Service,
        [string]$Errormessage
    )
    $cypher = @"
    MERGE (ComServer:ComServer { Name: `"$ComServerName`" })
    MERGE (ComInterface:ComInterface { UUID: `"$ComInterface`" })
    MERGE (endpoint:Endpoint { Name: `"$Endpoint`" })
    MERGE (ComServer)-[:HAS_INTERFACE]->(ComInterface)
    MERGE (ComInterface)-[:HAS_ENDPOINT]->(endpoint)
    MERGE (method:Method { Name: `"$MethodName`", Definition: `"$MethodDefinition`" })
    MERGE (ComInterface)-[:WITH_METHOD]->(method)
    CREATE (error:Error { 
        Name: `"$MethodName`", 
        Definition: `"$MethodDefinition`", 
        FuzzInput: `"$FuzzInput`",
        Endpoint: `"$Endpoint`",
        Error: `"$Errormessage`"
    })
    MERGE (method)-[:ERROR]->(error)

    FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
        MERGE (service:Service { Name: `"$Service`" })
        MERGE (ComServer)-[:SERVICE]->(service)

        FOREACH (_2 IN CASE WHEN `"$Errormessage`" CONTAINS 'The ALPC message requested is no longer available' THEN [1] ELSE [] END |
            MERGE (error)-[:CAUSES_CRASH]->(service)
        )
    )
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

# Function to create relationships for fuzzed input nodes that resulted in a function call in neo4j
<#
.SYNOPSIS
Creates relationships for fuzzed input nodes that resulted in a function call in neo4j
.DESCRIPTION
This function creates relationships for fuzzed input nodes that resulted in a function call in neo4j
.PARAMETER PMLEvent
One Process Monitor Event in CSV format
.PARAMETER Canary
The canary that was used when fuzzing
.OUTPUTS
None
#>
function Add-FunctionCallToAllowedInput {
    param (
        [PSObject]$PMLEvent,
        [string]$Canary
    )
    
    # Extract the relevant details from the $Event object
    $ProcessName = $PMLEvent.'Process Name'
    $Path = $PMLEvent.Path
    $Path = $Path -replace "\\", "\\"
    try {
        $fuzzinput = ($PMLEvent.Path -creplace "^.*\\$Canary", "$Canary")
    } catch {
        if ($_ -imatch "regular expression") {
            Write-Verbose "[!] Regex error with Canary, but we can continue"
        } else {
            Write-Verbose "[!] Error with Canary: $_"
        }
    }
    $fuzzinput = $fuzzinput -replace "\\", "\\"
    $Operation = $PMLEvent.Operation
    $eventPID = $PMLEvent.PID
    $user = $PMLEvent.User
    $detail = $PMLEvent.Detail
    $impersonating = "No impersonation"
    $AccessOptions = "Not Available"

    if ($detail -match "Impersonating:\s+([\S]+)") {
        $impersonating = $matches[1] -replace "\\", "\\"
    }

    # Extract Desired Access options if present
    if ($detail -match "Desired Access:\s*(.*?)(?=\s+\w+:)") {
        $AccessOptions = $matches[1].Trim()
    }

    # If no manual string input was parsed, we probably want to remove the '.'
    # This do prevent Process Monitor and Fuzzing input not being able to compare (because for some function calls, services add a extension)
    if (-not $StringInput) {
        $fuzzinput = ($fuzzinput -split '\.')[0]
    }

    # Also check for high privileged file operations without impersonation
    if ($Operation -match "file" -and $user -match "NT AUTHORITY" -and $impersonating -eq "No impersonation") {
        $cypher = @"
            MATCH (allowsinput:AllowsInput)
            WHERE allowsinput.FuzzInput CONTAINS `"$fuzzinput`"
            CREATE (highPrivilegedFileOp:HighPrivilegedFileOp {
                Path: `"$Path"`,
                Operation: `"$Operation"`,
                Process: `"$ProcessName"`,
                PID: `"$eventPID"`,
                User: `"$user"`,
                Impersonating: `"$impersonating"`,
                AccessOptions: `"$AccessOptions"`
            })
            MERGE (allowsinput)-[:HIGH_PRIVILEGED_FILE_OP]->(highPrivilegedFileOp)
"@  
    } else {
        # Find the existing 'AllowedInput' node by the method name and path
        $cypher = @"
            MATCH (allowsinput:AllowsInput)
            WHERE allowsinput.FuzzInput CONTAINS `"$fuzzinput`"
            CREATE (functionCall:FunctionCall {
                Path: `"$Path"`,
                Operation: `"$Operation"`,
                Process: `"$ProcessName"`,
                PID: `"$eventPID"`,
                User: `"$user"`,
                Impersonating: `"$impersonating"`,
                AccessOptions: `"$AccessOptions"`
            })
            MERGE (allowsinput)-[:CALLS_FUNCTION]->(functionCall)
"@
    }
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null   
}